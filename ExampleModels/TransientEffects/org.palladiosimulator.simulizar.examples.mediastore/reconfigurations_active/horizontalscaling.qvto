import org.palladiosimulator.simulizar.action.repository.black.SimulationStateLibrary;

/*
 * Two modeltypes are declared. The http NS URIs correspond to those used to register the 
 * Ecore models in the environment. Alternatively, a workspace metamodel may be used 
 * in conjunction with mappings defined in the project properties.
 */
modeltype RUNTIMEMEASUREMENT uses 'http://simulizar.palladiosimulator.org/RuntimeMeasurement/1.0';
modeltype PCM_ALLOC uses 'http://palladiosimulator.org/PalladioComponentModel/Allocation/5.1';
modeltype PCM_RES_ENV uses 'http://palladiosimulator.org/PalladioComponentModel/ResourceEnvironment/5.1';
modeltype PCM_REPOSITORY uses 'http://palladiosimulator.org/PalladioComponentModel/Repository/5.1';
modeltype PCM_ASSEMBLY uses 'http://palladiosimulator.org/PalladioComponentModel/Core/Composition/5.1';
modeltype ACTIONS uses 'http://simulizar.palladiosimulator.org/Actions/Core/1.1';
modeltype INSTANCE uses 'http://simulizar.palladiosimulator.org/Actions/Instance/1.1';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype SEFF uses 'http://palladiosimulator.org/PalladioComponentModel/SEFF/5.1';
modeltype SEFF_PERFORMANCE uses 'http://palladiosimulator.org/PalladioComponentModel/SEFF/SEFF_Performance/5.1';
modeltype PCM_PARAM uses 'http://palladiosimulator.org/PalladioComponentModel/Parameter/5.1';
modeltype PCM_CORE uses 'http://palladiosimulator.org/PalladioComponentModel/Core/5.1';
modeltype PCM_SYSTEM uses 'http://palladiosimulator.org/PalladioComponentModel/System/5.1';
modeltype STOEX uses 'http://sdq.ipd.uka.de/StochasticExpressions/2.2';

/*
 * The transformation signature declares that a RuntimeMeasurement modeltype is required as input, while an PCM
 * modeltype is transformed inplace. The RuntimeMeasurement modeltype is referenced as 'RuntimeMeasurement' throughout the 
 * transformation definition, while no name is needed for the output PCM modeltype. Note that OCL 
 * type and namespace notation are used in operational QVT (: and :: respectively).
 */
transformation outsource(	in runtimeMeasurement : RUNTIMEMEASUREMENT,
							inout pcmAllocation : PCM_ALLOC,
							inout actionsInput : ACTIONS,
							out roleSets : INSTANCE
							) {
							
							
	// Define Threshold and Scale Out
	property threshold : Real = 52000.0;
	property maximumInstances : Integer = 5;
	property adaptationBehaviorRepository : AdaptationBehaviorRepository = actionsInput.rootObjects()[core::AdaptationBehaviorRepository]->any(true);
	
	property reconfigurationTimeMetricId : String = '_VYg6MujFEeSB6OBq2SKZxQ';
	property responseTimeMetricId : String = '_6rYmYs7nEeOX_4BzImuHbA';
	property targetResourceContainerRoleId : String = '_9TESQRwLEeW4AMv4FxCz8w';
	property instantiatedComponentRoleId : String = '_p7wp4RwMEeW4AMv4FxCz8w';
	property controllerContainerRoleId : String = '_MEXt8RwNEeW4AMv4FxCz8w';
	property encapsulatedComponentAssemblyCtxId : String = '_Fslt8OXSEeSa__lJ2-JCxw2';
	property loadbalancerDownloadRequiredRole : String = '_LEN58OXSEeSa__lJ2-JCxw2';
	property branchId : String = '_nqCD0OXSEeSa__lJ2-JCxw2';
	property instantiateVmAdaptationBehaviorId : String = '_s5GsIRwJEeWmcO0Zlkc2yA';
	
	/**
	 * The main transformation.
	 * This is the entry point to the overall transformation.
	 */
	main() {
	
		log('SimuLizar Outsource Rule Transformation started');
		
		assert fatal(runtimeMeasurement.rootObjects()[RuntimeMeasurement]->size() > 0)
			with log ("No Measurements found!");
			
		assert fatal(pcmAllocation.rootObjects()[Allocation]->size() > 0)
			with log ("Allocation Model is empty!");
		
		runtimeMeasurement.rootObjects()[RuntimeMeasurement]
			->any(measurementSpecification.metricDescription.id = responseTimeMetricId)->checkScalingCondition();	
	}
	
	helper RuntimeMeasurement :: checkScalingCondition() : Boolean {
		log('Measured value is ' + self.measuringValue.toString());
		if (self.measuringValue > threshold and getSimulationTime() > 0.0) {
	
			log('Threshold is exceeded');
			pcmAllocation.rootObjects()[Allocation]->forEach(allocation) {
				log(allocation.targetResourceEnvironment_Allocation.resourceContainer_ResourceEnvironment->asSet()->size().toString() + " " + allocation.allocationContexts_Allocation.resourceContainer_AllocationContext->asSet()->size().toString());
				if(allocation.targetResourceEnvironment_Allocation.resourceContainer_ResourceEnvironment->asSet()->size() > allocation.allocationContexts_Allocation.resourceContainer_AllocationContext->asSet()->size()) {
					scaleUp(allocation);
				} else {
					assert fatal(false) with log('Maximum scaleout factor reached.');
				};
			};
			return true;
		};
		
		log('No measurements match the condition. Number of measurements is ' + self->size().toString());
		assert fatal(false) with log('No measurements match the condition.');
		return false;
	}
	
	/**
	 * outsource Processing.
	 */
	helper scaleUp(allocation : Allocation) : Boolean {
		var instantiatedComponent : BasicComponent := allocation.system_Allocation.assemblyContexts__ComposedStructure.encapsulatedComponent__AssemblyContext[BasicComponent]
					->any(id = "_o10-YHDrEeSqnN80MQ2uGw");
	
		log('Found ' +  allocation.allocationContexts_Allocation->size().toString() + ' AllocationContexts');
		var instantiateVm : AdaptationBehavior := adaptationBehaviorRepository.actions->any(id = instantiateVmAdaptationBehaviorId).oclAsType(AdaptationBehavior);
		var targetContainers := allocation.targetResourceEnvironment_Allocation.resourceContainer_ResourceEnvironment
			->reject(r | allocation.allocationContexts_Allocation.resourceContainer_AllocationContext->includes(r));
		var targetResourceContainer : ResourceContainer := targetContainers->any(true);
		var controllerContainer : ResourceContainer := allocation.allocationContexts_Allocation
			[assemblyContext_AllocationContext.encapsulatedComponent__AssemblyContext.id = encapsulatedComponentAssemblyCtxId].resourceContainer_AllocationContext->any(true);
		var roleSet : RoleSet := object RoleSet@roleSets {
			roles += object instance::Role {
				roleType := instantiateVm.getRoleTypeById(targetResourceContainerRoleId);
				value := targetResourceContainer.oclAsType(EObject);
			};
			roles += object instance::Role {
				roleType := instantiateVm.getRoleTypeById(instantiatedComponentRoleId);
				value := instantiatedComponent.oclAsType(EObject);
			};
			roles += object instance::Role {
				roleType := instantiateVm.getRoleTypeById(controllerContainerRoleId);
				value := controllerContainer.oclAsType(EObject);
			};	
		};
		
		// now execute the adaptation behavior
		var wasExecuted := instantiateVm.execute(roleSet);
		
		var instantiatedAllocation := allocation.allocationContexts_Allocation[resourceContainer_AllocationContext.id = targetResourceContainer.id
			and assemblyContext_AllocationContext.encapsulatedComponent__AssemblyContext.id = instantiatedComponent.id];
		log("Instantiated allocation " + instantiatedAllocation->any(true).entityName);
		instantiatedAllocation.map wireWithLoadBalancer(allocation);
		
		if(wasExecuted) {
			log('Migration executed');
		};
		return wasExecuted;
	}
	
	query AdaptationBehavior::getRoleTypeById(roleId : String) : RoleType {
		return self.involvedRoles[id = roleId]->any(true);
	}
	
	mapping AllocationContext::wireWithLoadBalancer(inout allocation : Allocation) {
		var lbAssembly : AssemblyContext := allocation.allocationContexts_Allocation.assemblyContext_AllocationContext[encapsulatedComponent__AssemblyContext.id = encapsulatedComponentAssemblyCtxId]->any(true);
		var lbComponent : BasicComponent := lbAssembly.encapsulatedComponent__AssemblyContext.oclAsType(BasicComponent);
		var operationRequiredRole : OperationRequiredRole := lbComponent.requiredRoles_InterfaceRequiringEntity[OperationRequiredRole]->any(id = loadbalancerDownloadRequiredRole);
		var number : Integer := lbComponent.requiredRoles_InterfaceRequiringEntity->size();
		var newOperationRequiredRole := object OperationRequiredRole {
			entityName := operationRequiredRole.entityName + number.toString();
			requiredInterface__OperationRequiredRole := operationRequiredRole.requiredInterface__OperationRequiredRole;
		};
		lbComponent.requiredRoles_InterfaceRequiringEntity += newOperationRequiredRole;
		var branchAction := lbComponent.serviceEffectSpecifications__BasicComponent[ResourceDemandingSEFF].steps_Behaviour[BranchAction]->any(true);
		var tBranchTransition := branchAction.branches_Branch->any(id = branchId);
		var newBranchTransition := object ProbabilisticBranchTransition {
			entityName := tBranchTransition.entityName + number.toString();
			branchBehaviour_BranchTransition := object ResourceDemandingBehaviour {
				var startAction : StartAction := object StartAction{};
				// TODO generalize this.
				var copiedCall := tBranchTransition.branchBehaviour_BranchTransition.steps_Behaviour[ExternalCallAction]->any(true);
				var externalCall := object ExternalCallAction {
					entityName := copiedCall.entityName + number.toString();				
					predecessor_AbstractAction := startAction;
					inputVariableUsages__CallAction := copiedCall.inputVariableUsages__CallAction.map copyVariableUsage();
					returnVariableUsage__CallReturnAction := copiedCall.returnVariableUsage__CallReturnAction.map copyVariableUsage();
					calledService_ExternalService := copiedCall.calledService_ExternalService;
					log("Called service " + calledService_ExternalService.id);
					role_ExternalService := newOperationRequiredRole;
				};
				var stopAction : StopAction := object StopAction {
					predecessor_AbstractAction := externalCall;
				};
				steps_Behaviour += startAction;
				steps_Behaviour += externalCall;
				steps_Behaviour += stopAction;
			};
		};
		branchAction.branches_Branch += newBranchTransition;
		var numberOfBranches : Real := branchAction.branches_Branch[ProbabilisticBranchTransition]->size();
		branchAction.branches_Branch[ProbabilisticBranchTransition]->forEach(branch) {
			log("Branch name " + branch.entityName);
			branch.branchProbability := 1.0 / number;
		};
		
		allocation.system_Allocation.connectors__ComposedStructure += object AssemblyConnector {
			entityName := lbAssembly.entityName + "->" + self.assemblyContext_AllocationContext.entityName;
			providingAssemblyContext_AssemblyConnector := self.assemblyContext_AllocationContext;
			requiringAssemblyContext_AssemblyConnector := lbAssembly;
			requiredRole_AssemblyConnector := newOperationRequiredRole;
			// TODO Is this generic enough for a template as there could be multiple provided roles?
			providedRole_AssemblyConnector := self.assemblyContext_AllocationContext.encapsulatedComponent__AssemblyContext.providedRoles_InterfaceProvidingEntity[OperationProvidedRole]->any(true);
		}
	}
	
	mapping VariableUsage::copyVariableUsage() : VariableUsage {
		variableCharacterisation_VariableUsage := self.variableCharacterisation_VariableUsage.map copyVariableCharacterisation();
		namedReference__VariableUsage := self.namedReference__VariableUsage.map copyNamedReference();
	}
	
	mapping VariableCharacterisation::copyVariableCharacterisation() : VariableCharacterisation {
		type := self.type;
		specification_VariableCharacterisation := object PCMRandomVariable {
			specification := self.specification_VariableCharacterisation.specification;
		}
	}
	
	mapping AbstractNamedReference::copyNamedReference() : AbstractNamedReference {
		init {
			result := null;
		}
		assert fatal(false) with log('AbstractNamedReference variant of copyNamedReference() should never be called');
	}
	
	mapping VariableReference::copyNamedReference() : AbstractNamedReference {
		init {
			result := object VariableReference {
				referenceName := self.referenceName;
			}
		}
	}
	
	mapping NamespaceReference::copyNamedReference() : AbstractNamedReference {
		init {
			result := object NamespaceReference {
				referenceName := self.referenceName;
				innerReference_NamespaceReference := self.innerReference_NamespaceReference.map copyNamedReference();
			}
		}
	}
}