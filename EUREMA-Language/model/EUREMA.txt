================================================================================

						   EUREMA Language
							Definitions &   						
						   Version History   						
						   ---------------   


================================================================================
							
							EUREMA v0.03							
					 		Mar 26, 2015
					 		
				TODO: describe changes of the language.

================================================================================
				Defining Changes of the Layer Diagram for 
				Offline Adaptation based on EUREMA v0.02
							Aug 25, 2014
						
The following changes of the Layer Diagram (LD) are allowed to adjust the 
adaptation engine by offline adaptation:

"Layers and megamodel modules (FLDs instances) can be added and removed from 
the engine. An individual module can be adapted by changing the bindings 
between its complex model operations and other megamodel modules, and between 
its basic model operations and software modules implementing these operations. 
[...] These adaptations change the number and composition of modules in 
flexible layers of the engine. Finally, LDs reflect the triggering conditions
of megamodel modules that can be dynamically changed." 

page 18:21 of Thomas Vogel and Holger Giese. 2014. Model-Driven Engineering of 
Self-Adaptive Software with EUREMA. ACM Trans. Auton. Adapt. Syst. 8, 4, 
Article 18 (January 2014), 33 pages. DOI=10.1145/2555612 
http://doi.acm.org/10.1145/2555612

In detail:

 -	An empty 'Layer', that is, a 'Layer' that does not contain any 'Module', 
	can be added or removed from the 'Architecture'.
 -	A 'Module' can be added or removed from a 'Layer'. All model elements 
	contained in the 'Module' are added or removed as well.
 -	The relationship
		MegamodelCall --binding--> MegamodelModule
	can be rerouted to point to another 'MegamodelModule' to be invoked by the 
	complex model operation.
 -	The relationship
		ModelOperation --binding--> SoftwareModule
	can be rerouted to point to another 'SoftwareModule' to be invoked by the 
	model operation.
 -	A trigger of a 'Module' can be changed as follows:
	 -	The 'period' of a 'Trigger' can be changed.
	 -	An 'Event' can be removed or added to a 'Trigger'.

The following changes are NOT allowed:

 -	The relationship
		MegamodelProxy --binding--> MegamodelModule
	can NOT be rerouted. This relationship is dependent on the megamodel module
	(and the module's sense and effect relationships to other modules, and the 
	module's operations) that contains the megamodel proxy. Changing the 
	relationship is typically not possible without changing the managed or the 
	managing megamodel module. Hence, the relationship can only be changed if 
	the managed or managing module is removed and an alternative module is 
	added, thus, the change of the relationship occurs together with the 
	replacement of a megamodel module.
 -	The relationship
		MegamodelModule --binding--> ModelResource
	can NOT be rerouted as this relationship points to the materialized EMF 
	model/resource.
 -	The relationship
		MegamodelModule --context--> ExecutionContext
	can NOT be rerouted as each megamodel module has exactly one and its 
	individual execution context.
 -	The relationship 
		Trigger --refers--> Sensing
	can NOT be rerouted as each trigger associated to exactly one and its 
	individual sensing relationship that connects two modules.
 -	The relationship 
		MegamodelModule --megamodel--> Megamodel 
	can NOT be rerouted as each module is considered as the instance of a 
	specific megamodel. Changing this relationship for a 'MegamodelModule' 
	would mean to change the type of the module. 
 -	The relationship 
		Event --type--> EventType
	can NOT be rerouted as it would dynamically change the type of the event. 
 -	A 'MegamodelModuleTrigger' or 'SoftwareModuleTrigger' can NOT be completely 
		removed from or added to a 'MegamodelModule' or 'SoftwareModule', 
		respectively.
 -	The following attributes can NOT be changed:
	 -	Layer.number
	 -	Layer.name
	 -	Module.uid
	 -	Module.name 
	 -	Sensing.name 
	 -	Effecting.name 
	 -	SoftwareModule.implementation
	 -	SoftwareModuleTrigger.isNative
	 -	SoftwareModuleTrigger.executionMethod
	 -	Event.name
	 -	Event.payload
	 -	EventType.type

	If values of these attributes should be changed, a new instance of the 
	corresponding class must be created that may replace an existing instance 
	of the same class. 
	For instance, instead of changing the name of an event that is used in a 
	trigger, a new event with the desired name must be created and added to the 
	trigger. The event with the outdated or undesired name can be removed from 
	the trigger.





================================================================================

							EUREMA v0.02							
					 		Oct 09, 2013							


The following changes adapt EUREMA v0.01 resulting in EUREMA v0.02:

 -  The name of the metaclass 'MegamodelTrigger' has been changed to
	'MegamodelModuleTrigger'. The reason for the change is that 
	triggering conditions are specified for modules that are either 
	instances of 'Software' or 'Megamodel'. Therefore, two types of 
	triggers exist: 'SoftwareModuleTrigger' & 'MegamodelModuleTrigger'

 -  The multiplicity of the relationship 
		SoftwareModule --trigger--> SoftwareModuleTrigger
	has been changed from 0..* to 0..1.
	Likewise, the multiplicity of the relationship
		MegamodelModule --triggers--> MegamodelModuleTrigger
	has been changed from 0..* to 0..1. According to this change, the
	name of the relationship has been changed from 'triggers' to 
	'trigger'.

	The reason for these changes is that a module, either a software
	or megamodel module, may have no or at most one triggering 
	condition.

 -  The concepts of 'Operation' and 'Transition' are modified by 
	making the entry and exit compartments of an operation explicit 
	in the metamodel.

	EUREMA v0.01 defined their relationship as follows:

		Operation --outgoing 0..*--> Transition
		Transition --source 1--> Operation
		Operation --incoming 0..*--> Transition
		Transition --target 1--> Operation

	while an 'Operation' and a 'Transition' have a name attribute.

	In the Feedback Loop Diagram (FLD), an 'Operation' is labeled by 
	its name. A transition is not labeled (except of outgoing 
	transitions of a 'DecisionOperation', which are labeled by 
	conditions) but the transition's name is used to label the exit 
	compartment of the transition's source operation (each exit 
	compartment of an 'Operation' is the source of exactly one 
	'Transition'). This implicitly covers the exit compartments of an 
	'Operation' in the metamodel. The problem with this definition and 
	approach is that the entry compartments of an 'Operation' and the 
	names of the entry compartments are not reflected at all by the 
	metamodel, neither explicitly nor implicitly. However, entry 
	compartments are required if more than one entry exist (cf. 
	Figure 4.3 in [1]).

	Therefore, entry and exit compartments are now made explicit by
	EUREMA v0.02:

		Operation --exits 0..*--> Exit
		Exit --operation 1--> Operation
		Exit --outgoing 1--> Transition
		Transition --source 1--> Exit

		Operation --entry 0..*--> Entry
		Entry --operation 1--> Operation
		Entry --incoming 1..*--> Transition
		Transition --target 1--> Entry

	Thus, a 'Transition' connects exactly one 'Entry' and one 'Exit' 
	of different 'Operations'. An 'Entry' has at least one incoming 
	'Transition' and an 'Exit' has exactly one outgoing 'Transition'.
	The latter ensures determinism. An 'Entry' or 'Exit' belongs to 
	exactly one 'Operation'. Moreover, 'Entry' and 'Exit' are 
	subclassing the 'MegamodelElement'.

	The following constraints apply to these definitions:

	- An 'InitialOperation' has no 'Entry' and exactly one 'Exit'.
	- A 'FinalOperation' has 1..* 'Entry' and and no 'Exit'.
	- A 'DecisionOperation' has 1..* 'Entry' and 2..* 'Exit'. 
	  The at least two exists are motivated by the fact that a 
	  decision operation branches the control flow in an FLD and thus,
	  at least two exits as alternatives for continuing the control 
	  flow are required.
	- An 'OperationBehavior' ('ModelOperation' and 'MegamodelCall')
	  has 1..* 'Entry' and 1..* 'Exit'.


	This change in the relationships between an 'Operation' and a 
	'Transition' also affects the mapping of the incoming and outgoing 
	transitions (that are the 'Entry' and'Exit') of a 'MegamodelCall' 
	to the 'InitialOperation'/'FinalOperation' of the invoked 
	megamodel.

	In EUREMA v0.01, incoming (outgoing) 'Transition' of a 
	'MegamodelCall' invoking a megamodel are mapped to 
	'InitialOperation' ('FinalOperation') of the invoked megamodel. 
	This does not work since the name of the transition connecting an 
	exit compartment of an operation to an entry compartment of 
	another operation is used to label the related exit compartment 
	and there is no other name attribute left in the metamodel to 
	label the entry compartment. Entry compartments are only 
	implicitly reflected in the metamodel by outgoing transitions of 
	an operation while entry compartments are not reflected at all.

	In EUREMA v0.02, the 'Entry' ('Exit') of a 'MegamodelCall' 
	invoking a megamodel are mapped to the 'InitialOperation' 
	('FinalOperation') of the invoked megamodel by using names:

		'Entry.name' must map to 'InitialOperation.name'
		'Exit.name' must map to 'FinalOperation.name'

	Explicit references among 'Entry' ('Exit') and 'InitialOperation' 
	('FinalOperation') are not feasible because it complicates the 
	instantiation of megamodels to megamodel modules. 
	Since the instantiation is based on copying a megamodel, 
	references among elements of different megamodels requires to copy 
	all interrelated megamodels. This establishes bindings among 
	modules during instantiation as well as a ono-to-one image of the 
	megamodel level (that is the type level) to the module level (that 
	is the instance level), which is not desired. 
	Bindings should be made explicitly in a Layer Diagram (LD). 
	However, mappings by names avoids these interrelated megamodels by 
	implicitly establishing references, which are resolved after a 
	'MegamodelCall' is bound to a 'MegamodelModule' to be invoked in 
	the LD.
	Thus, a megamodel does not contain any reference to any other 
	megamodel. Thus, it is self-contained and can be instantiated 
	independently from other megamodels. However, 'Entry' and 'Exit' 
	names of a 'MegamodelCall' must map to 'InitialOperation' and 
	'FinalOperation' names of the module, to which the 'MegamodelCall'
	is bound. This ensures that the 'MegamodelCall' can be properly 
	executed by invoking the megamodel module in its proper initial 
	state and by properly continuing execution after the module has 
	terminated in its final state (Note: The 'InitialOperation' 
	('FinalOperation') is also called initial (final) sate).


	Further implications for the FLD:

	- In the FLD, a 'Transition' is not labeled by its name and this 
	  name is event not shown in the FLD. To ease modeling, the 
	  'Transition' can be assigned the same name as the 'Exit' that is
	  the source of the 'Transition'. The names of 'Entry' and 'Exit' 
	  are used in the FLD to label the entry and exit compartments of
	  an 'OperationBehavior' ('ModelOperation' and 'MegamodelCall'). 
	  For 'InitialOperation', 'FinalOperation', and 
	  'DecisionOperation' the entry and exit compartments are not 
	  shown in the FLD.




=====================================================================

							EUREMA v0.01							


This version of the metamodel is described in the following technical 
report [1] while the following changes have been applied to the metamodel:

 -  'MegamodelPoxy' has been changed to 'MegamodelProxy' (typo removed)
 -  A new attribute called 'payload' has been added to the 'Event' 
	metaclass to reflect the content of an event occurring at runtime.
	The payload is determined at runtime when, for instance, the 
	adaptable software emits an exception event and the payload 
	reflects details of the exception. Thus, the payload is modeled
	by the engineer.



=====================================================================

REFERENCES

 [1]	Thomas Vogel and Holger Giese. Model-Driven Engineering of 
		Adaptation Engines for Self-Adaptive Software: Executable 
		Runtime Megamodels. Technical Report 66, Hasso Plattner 
		Institute for Software Systems Engineering, University of 
		Potsdam, Germany, 4 2013. 
		http://opus.kobv.de/ubp/volltexte/2013/6382/



