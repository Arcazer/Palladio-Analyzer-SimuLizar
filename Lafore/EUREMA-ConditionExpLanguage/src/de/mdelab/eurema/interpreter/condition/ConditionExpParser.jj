options{  JDK_VERSION = "1.6";  DEBUG_PARSER = false;  static = false;}PARSER_BEGIN(ConditionExpParser)package de.mdelab.eurema.interpreter.condition;import de.mdelab.eurema.interpreter.condition.QueryExecutionInformation;import java.io.StringReader;import java.io.Reader;public class ConditionExpParser{  private QueryExecutionInformation qei;  public ConditionExpParser()  {    // Initialize parser with empty expression.    // Expression to be parsed and evaluated is set by the parseExp method.    this ((Reader) (new StringReader("")));  }  public boolean parseExp(String s, QueryExecutionInformation qei)  {    this.ReInit((Reader) (new StringReader(s)));    this.qei = qei;    try    {      return this.parse();    }    catch (Exception e)    {      e.printStackTrace();      throw new RuntimeException(e);    }  }}PARSER_END(ConditionExpParser)/**  And now, the actual parsing specifications...... *//** Skip these characters, they are considered "white space" **/SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < NOT : "NOT" >| < AND : "AND" >| < OR : "OR" >| < ELSE : "ELSE" >| < LPAREN : "(" >| < RPAREN : ")" >| < EQUALS : "=" >| < NOT_EQUALS : "<>" >| < GREATER : ">" >| < SMALLER : "<" >| < GREATER_EQUALS : ">=" >| < SMALLER_EQUALS : "<=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < CURRENT_TIME : "CURRENT_TIME" >| < SEPARATOR : "::" >}TOKEN :{  < NUMBER : ([ "0"-"9" ])+ >}SPECIAL_TOKEN :{  < C_SINCE : "C_SINCE" > : IN_METHOD| < T_WHEN : "T_WHEN" > : IN_METHOD}< IN_METHOD >SKIP :{  < START_PARAM : < LPAREN >>}< IN_METHOD >TOKEN :{  < PARAM :    [ "A"-"Z", "a"-"z", "0"-"9" ] (([ " " ])? [ "A"-"Z", "a"-"z", "0"-"9" ])*    (      < SEPARATOR > [ "A"-"Z", "a"-"z", "0"-"9" ] (([ " " ])? [ "A"-"Z", "a"-"z", "0"-"9" ])*    )? >  : END_METHOD}< END_METHOD >SKIP :{  < END_PARAM : < RPAREN >> : DEFAULT}/**  *  Top level */boolean parse() :{  boolean result;}{  result = exp() < EOF >  {    return result;  }}/*** Expression*/boolean exp() :{  boolean left;  boolean right;  boolean isAND = false;}{  left = boolExp()  (    (      < AND >      {        isAND = true;      }    | < OR >      {        isAND = false;      }    )    right = boolExp()    {      if (isAND)      {        return left && right;      }      else      {        return left || right;      }    }  )*  {    return left;  }}/*** Boolean Expression*/boolean boolExp() :{  boolean result;  long left;  long right;  boolean isEquals = false;  boolean isNotEquals = false;  boolean isGreater = false;  boolean isSmaller = false;  boolean isGreaterEquals = false;  boolean isSmallerEquals = false;}{  LOOKAHEAD((< LPAREN >)+ boolExp() ("AND"| "OR"))  < LPAREN > result = exp() < RPAREN >  {    return result;  }| < NOT > < LPAREN > result = exp() < RPAREN >  {    return !result;  }| left = sumExp()  (    < EQUALS >    {      isEquals = true;    }  | < NOT_EQUALS >    {      isNotEquals = true;    }  | < GREATER >    {      isGreater = true;    }  | < SMALLER >    {      isSmaller = true;    }  | < GREATER_EQUALS >    {      isGreaterEquals = true;    }  | < SMALLER_EQUALS >    {      isSmallerEquals = true;    }  )  right = sumExp()  {    if (isEquals)    {      return left == right;    }    else if (isNotEquals)    {      return left != right;    }    else if (isGreater)    {      return left > right;    }    else if (isSmaller)    {      return left < right;    }    else if (isGreaterEquals)    {      return left >= right;    }    else if (isSmallerEquals)    {      return left <= right;    }  }}/*** PLUS, MINUS*/long sumExp() :{  long left;  long right;  boolean isPlus = false;}{  left = termExp()  (    (      < PLUS >      {        isPlus = true;      }    | < MINUS >      {        isPlus = false;      }    )    right = termExp()    {      if (isPlus)      {        return left + right;      }      else      {        return left - right;      }    }  )*  {    return left;  }}/*** MULTIPLY, DIVIDE*/long termExp() :{  long left;  long right;  boolean isMult = false;}{  left = unary()  (    (      < MULTIPLY >      {        isMult = true;      }    | < DIVIDE >      {        isMult = false;      }    )    right = unary()    {      if (isMult)      {        return left * right;      }      else      {        return left / right;      }    }  )*  {    return left;  }}/*** Basic Numerical Expression*/long unary() :{  long result;}{  < MINUS > result = element()  {    return result * - 1;  }| result = element()  {    return result;  }}long element() :{  Token token;  long result;}{  < LPAREN > result = sumExp() < RPAREN >  {    return result;  }| token = < NUMBER >  {    return Long.parseLong(token.image);  }| < CURRENT_TIME >  {    return System.currentTimeMillis();  }| token = < PARAM >  {    //System.out.println(token.image + " ==== " + token.specialToken.image);    if (token.specialToken.image.equals("C_SINCE"))    {      return this.qei.retrieveCount(token.image);    }    else if (token.specialToken.image.equals("T_WHEN"))    {      return this.qei.retrieveTime(token.image);    }  }}